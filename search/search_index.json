{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Basisregisters Vlaanderen \u00b6 Guides \u00b6 To get an idea on how our system works, we have written several guides documenting each step involved. It is advised you read these in order to get started: Starting a new registry Sending commands to the domain Reacting to commands Storing events using SqlStreamStore License \u00b6 European Union Public Licence (EUPL) The new version 1.2 of the European Union Public Licence (EUPL) is published in the 23 EU languages in the EU Official Journal: Commission Implementing Decision (EU) 2017/863 of 18 May 2017 updating the open source software licence EUPL to further facilitate the sharing and reuse of software developed by public administrations ( OJ 19/05/2017 L128 p. 59\u201364 ).","title":"Home"},{"location":"#welcome-to-basisregisters-vlaanderen","text":"","title":"Welcome to Basisregisters Vlaanderen"},{"location":"#guides","text":"To get an idea on how our system works, we have written several guides documenting each step involved. It is advised you read these in order to get started: Starting a new registry Sending commands to the domain Reacting to commands Storing events using SqlStreamStore","title":"Guides"},{"location":"#license","text":"European Union Public Licence (EUPL) The new version 1.2 of the European Union Public Licence (EUPL) is published in the 23 EU languages in the EU Official Journal: Commission Implementing Decision (EU) 2017/863 of 18 May 2017 updating the open source software licence EUPL to further facilitate the sharing and reuse of software developed by public administrations ( OJ 19/05/2017 L128 p. 59\u201364 ).","title":"License"},{"location":"build/","text":"Build Script \u00b6 Our build.sh script knows a few tricks. By default it runs with the Test target. The buildserver passes in BITBUCKET_BUILD_NUMBER as an integer to version the results and BUILD_DOCKER_REGISTRY to point to a Docker registry to push the resulting Docker images. NpmInstall \u00b6 Run an npm install to setup Commitizen and Semantic Release . DotNetCli \u00b6 Checks if the requested .NET Core SDK and runtime version defined in global.json are available. We are pedantic about these being the exact versions to have identical builds everywhere. Clean \u00b6 Make sure we have a clean build directory to start with. Restore \u00b6 Restore dependencies for debian.8-x64 and win10-x64 using dotnet restore and Paket. Build \u00b6 Builds the solution in Release mode with the .NET Core SDK and runtime specified in global.json It builds it platform-neutral, debian.8-x64 and win10-x64 version. Test \u00b6 Runs dotnet test against the test projects. Publish \u00b6 Runs a dotnet publish for the debian.8-x64 and win10-x64 version as a self-contained application. It does this using the Release configuration. Pack \u00b6 Packs the solution using Paket in Release mode and places the result in the dist folder. This is usually used to build documentation NuGet packages. Containerize \u00b6 Executes a docker build to package the application as a docker image. It does not use a Docker cache. The result is tagged as latest and with the current version number. DockerLogin \u00b6 Executes ci-docker-login.sh , which does an aws ecr login to login to Amazon Elastic Container Registry. This uses the local aws settings, make sure they are working! Push \u00b6 Executes docker push to push the built images to the registry.","title":"Build Script"},{"location":"build/#build-script","text":"Our build.sh script knows a few tricks. By default it runs with the Test target. The buildserver passes in BITBUCKET_BUILD_NUMBER as an integer to version the results and BUILD_DOCKER_REGISTRY to point to a Docker registry to push the resulting Docker images.","title":"Build Script"},{"location":"build/#npminstall","text":"Run an npm install to setup Commitizen and Semantic Release .","title":"NpmInstall"},{"location":"build/#dotnetcli","text":"Checks if the requested .NET Core SDK and runtime version defined in global.json are available. We are pedantic about these being the exact versions to have identical builds everywhere.","title":"DotNetCli"},{"location":"build/#clean","text":"Make sure we have a clean build directory to start with.","title":"Clean"},{"location":"build/#restore","text":"Restore dependencies for debian.8-x64 and win10-x64 using dotnet restore and Paket.","title":"Restore"},{"location":"build/#build","text":"Builds the solution in Release mode with the .NET Core SDK and runtime specified in global.json It builds it platform-neutral, debian.8-x64 and win10-x64 version.","title":"Build"},{"location":"build/#test","text":"Runs dotnet test against the test projects.","title":"Test"},{"location":"build/#publish","text":"Runs a dotnet publish for the debian.8-x64 and win10-x64 version as a self-contained application. It does this using the Release configuration.","title":"Publish"},{"location":"build/#pack","text":"Packs the solution using Paket in Release mode and places the result in the dist folder. This is usually used to build documentation NuGet packages.","title":"Pack"},{"location":"build/#containerize","text":"Executes a docker build to package the application as a docker image. It does not use a Docker cache. The result is tagged as latest and with the current version number.","title":"Containerize"},{"location":"build/#dockerlogin","text":"Executes ci-docker-login.sh , which does an aws ecr login to login to Amazon Elastic Container Registry. This uses the local aws settings, make sure they are working!","title":"DockerLogin"},{"location":"build/#push","text":"Executes docker push to push the built images to the registry.","title":"Push"},{"location":"new-registry/","text":"Starting a new registry \u00b6 To get started building a new registry based of the example registry , follow these steps: Preparing the example registry \u00b6 Downloading the example registry \u00b6 Start by downloading the example registry and extracting it in your new location. Renaming physical files to match your project \u00b6 Rename the following files to your project name: ExampleRegistry.sln ExampleRegistry.sln.DotSettings src\\ExampleRegistry src\\ExampleRegistry\\ExampleRegistry.csproj src\\ExampleRegistry\\ExampleRegistry.csproj.DotSettings src\\ExampleRegistry\\ExampleRegistryException.cs src\\ExampleRegistry.Api src\\ExampleRegistry.Api\\ExampleRegistry.Api.csproj src\\ExampleRegistry.Api\\ExampleRegistry.Api.csproj.DotSettings src\\ExampleRegistry.Api\\Infrastructure\\ExampleRegistryController.cs src\\ExampleRegistry.Infrastructure src\\ExampleRegistry.Infrastructure\\ExampleRegistry.Infrastructure.csproj test\\ExampleRegistry.Tests test\\ExampleRegistry.Tests\\ExampleRegistry.Tests.csproj test\\ExampleRegistry.Tests\\ExampleRegistryTest.cs docs\\ExampleRegistry.Structurizr docs\\ExampleRegistry.Structurizr\\ExampleRegistry.Structurizr.csproj Renaming code to match your project \u00b6 Do a case sensitive search in all files for the following and replace it, respecting the casing: Project Details \u00b6 ExampleRegistry to your project name. example-registry to your project name. exampleregistry to your project name. exampleRegistry to your project name. Example Registry to your project name. Example Api to your project name + Api . Write a short summary of the business goal of this registry. to clarify what your project is about. Organisation Details \u00b6 informatievlaanderen to your organisation GitHub name. agentschap Informatie Vlaanderen to your organisation name. Basisregisters Vlaanderen to your organisation name. Informatie Vlaanderen to your organisation name. Vlaamse overheid to your organisation name. informatie.vlaanderen@vlaanderen.be to your organisation contact email address. https://vlaanderen.be/informatie-vlaanderen to your organisation website address. \"Havenlaan 88\" to your organisation street. \"1000\" to your organisation postal code. \"Brussel\" to your organisation city. Generate unique assembly Guids \u00b6 Search for [assembly: Guid in every AssemblyInfo.cs and generate a new guid for each. Enabling HTTPS with a certificate \u00b6 In src\\ExampleRegistry.Api\\Infrastructure\\Program.cs there is a DevelopmentCertificate property used to configure the SSL certificate. If you wish to use example.pfx , which is a self-signed certificate for localhost , use the password example-registry! Building for the first time \u00b6 Run build.sh Pack to verify everything is correct. This will also pull down all required packages to later open the solution properly with Visual Studio. Running the registry using Visual Studio \u00b6 To try out the registry for the first time, open up YourRegistry.sln in Visual Studio. Set YourRegistry.Api as a startup project and select YourRegistry.Api as Debug Emulator instead of IIS Express . Start the registry and browse to localhost:1090 , you should see the API documentation. Browsing to localhost:1090/v1/example/SOMEKEY should return SOMEKEY . At this point you have a working development environment to build upon. The next step is to send commands to the domain .","title":"New Registry"},{"location":"new-registry/#starting-a-new-registry","text":"To get started building a new registry based of the example registry , follow these steps:","title":"Starting a new registry"},{"location":"new-registry/#preparing-the-example-registry","text":"","title":"Preparing the example registry"},{"location":"new-registry/#downloading-the-example-registry","text":"Start by downloading the example registry and extracting it in your new location.","title":"Downloading the example registry"},{"location":"new-registry/#renaming-physical-files-to-match-your-project","text":"Rename the following files to your project name: ExampleRegistry.sln ExampleRegistry.sln.DotSettings src\\ExampleRegistry src\\ExampleRegistry\\ExampleRegistry.csproj src\\ExampleRegistry\\ExampleRegistry.csproj.DotSettings src\\ExampleRegistry\\ExampleRegistryException.cs src\\ExampleRegistry.Api src\\ExampleRegistry.Api\\ExampleRegistry.Api.csproj src\\ExampleRegistry.Api\\ExampleRegistry.Api.csproj.DotSettings src\\ExampleRegistry.Api\\Infrastructure\\ExampleRegistryController.cs src\\ExampleRegistry.Infrastructure src\\ExampleRegistry.Infrastructure\\ExampleRegistry.Infrastructure.csproj test\\ExampleRegistry.Tests test\\ExampleRegistry.Tests\\ExampleRegistry.Tests.csproj test\\ExampleRegistry.Tests\\ExampleRegistryTest.cs docs\\ExampleRegistry.Structurizr docs\\ExampleRegistry.Structurizr\\ExampleRegistry.Structurizr.csproj","title":"Renaming physical files to match your project"},{"location":"new-registry/#renaming-code-to-match-your-project","text":"Do a case sensitive search in all files for the following and replace it, respecting the casing:","title":"Renaming code to match your project"},{"location":"new-registry/#project-details","text":"ExampleRegistry to your project name. example-registry to your project name. exampleregistry to your project name. exampleRegistry to your project name. Example Registry to your project name. Example Api to your project name + Api . Write a short summary of the business goal of this registry. to clarify what your project is about.","title":"Project Details"},{"location":"new-registry/#organisation-details","text":"informatievlaanderen to your organisation GitHub name. agentschap Informatie Vlaanderen to your organisation name. Basisregisters Vlaanderen to your organisation name. Informatie Vlaanderen to your organisation name. Vlaamse overheid to your organisation name. informatie.vlaanderen@vlaanderen.be to your organisation contact email address. https://vlaanderen.be/informatie-vlaanderen to your organisation website address. \"Havenlaan 88\" to your organisation street. \"1000\" to your organisation postal code. \"Brussel\" to your organisation city.","title":"Organisation Details"},{"location":"new-registry/#generate-unique-assembly-guids","text":"Search for [assembly: Guid in every AssemblyInfo.cs and generate a new guid for each.","title":"Generate unique assembly Guids"},{"location":"new-registry/#enabling-https-with-a-certificate","text":"In src\\ExampleRegistry.Api\\Infrastructure\\Program.cs there is a DevelopmentCertificate property used to configure the SSL certificate. If you wish to use example.pfx , which is a self-signed certificate for localhost , use the password example-registry!","title":"Enabling HTTPS with a certificate"},{"location":"new-registry/#building-for-the-first-time","text":"Run build.sh Pack to verify everything is correct. This will also pull down all required packages to later open the solution properly with Visual Studio.","title":"Building for the first time"},{"location":"new-registry/#running-the-registry-using-visual-studio","text":"To try out the registry for the first time, open up YourRegistry.sln in Visual Studio. Set YourRegistry.Api as a startup project and select YourRegistry.Api as Debug Emulator instead of IIS Express . Start the registry and browse to localhost:1090 , you should see the API documentation. Browsing to localhost:1090/v1/example/SOMEKEY should return SOMEKEY . At this point you have a working development environment to build upon. The next step is to send commands to the domain .","title":"Running the registry using Visual Studio"},{"location":"reacting-to-commands/","text":"Reacting to commands \u00b6 The main input of a system is commands, which are handled by command handlers. We support two different type of command handlers, regular ones and event sourced handlers. Regular Command Handlers \u00b6 A regular command handler is simply a class which is subscribed to commands and does not need anything from the event sourcing infrastructure. This means it is not possible to easily fetch aggregates nor store events to the event store. Registering \u00b6 To register this type of command handler, use the following syntax in the CommandHandlerModules registration: // Syntax for commandhandlers which do not use SqlStreamStore to store events containerBuilder . RegisterType < SimpleExampleCommandHandlerModule >() . Named < CommandHandlerModule >( typeof ( SimpleExampleCommandHandlerModule ). FullName ) . As < CommandHandlerModule >(); Implementation \u00b6 A handler can then simple register commands with the For syntax and receive the message : public sealed class SimpleExampleCommandHandlerModule : CommandHandlerModule { public SimpleExampleCommandHandlerModule () { For < DoSimpleExample >() . Handle ( message => { Console . WriteLine ( $ \"A simple example arrived, saying {message.Command.Name.Name} in {message.Command.Name.Language}!\" ); }); } } Event Sourced Command Handlers \u00b6 Event sourced command handlers are able to easily get aggregates by id from a repository, create new aggregates as well as transparently store created events using SqlStreamStore. Registering \u00b6 To register this type of command handler, use the following syntax in the CommandHandlerModules registration: // Syntax for EventSourcing with SqlStreamStore containerBuilder . RegisterSqlStreamStoreCommandHandler < ExampleCommandHandlerModule >( c => handler => new ExampleCommandHandlerModule ( c . Resolve < Func < IExamples >>(), handler )); Implementation \u00b6 A handler also uses For to register for commands but it uses a finalHandler to enable auto-saving of events. For example, this handler looks up an aggregate based on an identifier and if it does not exist, creates the aggregate and adds it to the repository: NOTE: At this point, this example will not work yet, since you have not set up storing events yet. public sealed class ExampleCommandHandlerModule : CommandHandlerModule { public ExampleCommandHandlerModule ( Func < IExamples > getExamples , ReturnHandler < CommandMessage > finalHandler = null ) : base ( finalHandler ) { For < DoExample >() . Handle ( async ( message , ct ) => { var examples = getExamples (); var exampleId = message . Command . ExampleId ; var possibleExample = await examples . GetOptionalAsync ( exampleId , ct ); if (! possibleExample . HasValue ) { possibleExample = new Optional < Example >( Example . Register ( exampleId )); examples . Add ( exampleId , possibleExample . Value ); } var example = possibleExample . Value ; example . DoExample ( message . Command . Name ); }); } } The above code calls DoExample on an aggregate which generates events and are saved automatically when the command is handled. The aggregate looks as follows: public partial class Example : AggregateRootEntity { public static readonly Func < Example > Factory = () => new Example (); public static Example Register ( ExampleId id ) { var example = Factory (); example . ApplyChange ( new ExampleWasBorn ( id )); return example ; } public void DoExample ( ExampleName name ) { ApplyChange ( new ExampleHappened ( _exampleId , name )); } } The created events are then stored using SqlStreamStore .","title":"Receiving Commands"},{"location":"reacting-to-commands/#reacting-to-commands","text":"The main input of a system is commands, which are handled by command handlers. We support two different type of command handlers, regular ones and event sourced handlers.","title":"Reacting to commands"},{"location":"reacting-to-commands/#regular-command-handlers","text":"A regular command handler is simply a class which is subscribed to commands and does not need anything from the event sourcing infrastructure. This means it is not possible to easily fetch aggregates nor store events to the event store.","title":"Regular Command Handlers"},{"location":"reacting-to-commands/#registering","text":"To register this type of command handler, use the following syntax in the CommandHandlerModules registration: // Syntax for commandhandlers which do not use SqlStreamStore to store events containerBuilder . RegisterType < SimpleExampleCommandHandlerModule >() . Named < CommandHandlerModule >( typeof ( SimpleExampleCommandHandlerModule ). FullName ) . As < CommandHandlerModule >();","title":"Registering"},{"location":"reacting-to-commands/#implementation","text":"A handler can then simple register commands with the For syntax and receive the message : public sealed class SimpleExampleCommandHandlerModule : CommandHandlerModule { public SimpleExampleCommandHandlerModule () { For < DoSimpleExample >() . Handle ( message => { Console . WriteLine ( $ \"A simple example arrived, saying {message.Command.Name.Name} in {message.Command.Name.Language}!\" ); }); } }","title":"Implementation"},{"location":"reacting-to-commands/#event-sourced-command-handlers","text":"Event sourced command handlers are able to easily get aggregates by id from a repository, create new aggregates as well as transparently store created events using SqlStreamStore.","title":"Event Sourced Command Handlers"},{"location":"reacting-to-commands/#registering_1","text":"To register this type of command handler, use the following syntax in the CommandHandlerModules registration: // Syntax for EventSourcing with SqlStreamStore containerBuilder . RegisterSqlStreamStoreCommandHandler < ExampleCommandHandlerModule >( c => handler => new ExampleCommandHandlerModule ( c . Resolve < Func < IExamples >>(), handler ));","title":"Registering"},{"location":"reacting-to-commands/#implementation_1","text":"A handler also uses For to register for commands but it uses a finalHandler to enable auto-saving of events. For example, this handler looks up an aggregate based on an identifier and if it does not exist, creates the aggregate and adds it to the repository: NOTE: At this point, this example will not work yet, since you have not set up storing events yet. public sealed class ExampleCommandHandlerModule : CommandHandlerModule { public ExampleCommandHandlerModule ( Func < IExamples > getExamples , ReturnHandler < CommandMessage > finalHandler = null ) : base ( finalHandler ) { For < DoExample >() . Handle ( async ( message , ct ) => { var examples = getExamples (); var exampleId = message . Command . ExampleId ; var possibleExample = await examples . GetOptionalAsync ( exampleId , ct ); if (! possibleExample . HasValue ) { possibleExample = new Optional < Example >( Example . Register ( exampleId )); examples . Add ( exampleId , possibleExample . Value ); } var example = possibleExample . Value ; example . DoExample ( message . Command . Name ); }); } } The above code calls DoExample on an aggregate which generates events and are saved automatically when the command is handled. The aggregate looks as follows: public partial class Example : AggregateRootEntity { public static readonly Func < Example > Factory = () => new Example (); public static Example Register ( ExampleId id ) { var example = Factory (); example . ApplyChange ( new ExampleWasBorn ( id )); return example ; } public void DoExample ( ExampleName name ) { ApplyChange ( new ExampleHappened ( _exampleId , name )); } } The created events are then stored using SqlStreamStore .","title":"Implementation"},{"location":"sending-commands/","text":"Sending commands to the domain \u00b6 A system can receive input from various sources. Eventually all of these need to get translated into commands which are sent to the domain. The way these commands are created is up to the implementor. Commands in their turn are sent to the domain by dispatching them on a bus. In its simplest form, a command is sent over the bus using bus.Dispatch(commandId, command) towards the domain. In this example, we have an MVC controller where incoming commands are sent to as plain JSON objects for simplicity, converted into a command object and placed on the bus. public class CommandRequest { /// <summary>Type of the command.</summary> [Required] public string Type { get ; set ; } /// <summary>The raw command.</summary> [Required] public string Command { get ; set ; } } public static class CommandRequestMapping { public static dynamic Map ( CommandRequest message ) { var assembly = typeof ( DomainAssemblyMarker ). Assembly ; var type = assembly . GetType ( message . Type ); return JsonConvert . DeserializeObject ( message . Command , type ); } } public class ExampleController : ExampleRegistryController { /// <summary> /// Execute a generic command. /// </summary> /// <param name=\"bus\"></param> /// <param name=\"commandId\">Optional unique id for the request.</param> /// <param name=\"command\"></param> /// <param name=\"cancellationToken\"></param> /// <response code=\"202\">If the request is accepted.</response> /// <response code=\"400\">If the request has invalid data.</response> /// <response code=\"500\">If an internal error has occured.</response> /// <returns></returns> [HttpPost] [ProducesResponseType(typeof(void), StatusCodes.Status202Accepted)] [ProducesResponseType(typeof(BasicApiProblem), StatusCodes.Status400BadRequest)] [ProducesResponseType(typeof(BasicApiProblem), StatusCodes.Status500InternalServerError)] [SwaggerRequestExample(typeof(CommandRequest), typeof(CommandRequestExample))] [SwaggerResponseExample(StatusCodes.Status202Accepted, typeof(CommandResponseExamples), jsonConverter: typeof(StringEnumConverter))] [SwaggerResponseExample(StatusCodes.Status400BadRequest, typeof(BadRequestResponseExamples), jsonConverter: typeof(StringEnumConverter))] [SwaggerResponseExample(StatusCodes.Status500InternalServerError, typeof(InternalServerErrorResponseExamples), jsonConverter: typeof(StringEnumConverter))] public async Task < IActionResult > Post ( [FromServices] ICommandHandlerResolver bus , [FromCommandId] Guid commandId , [FromBody] CommandRequest command , CancellationToken cancellationToken = default ) { if (! ModelState . IsValid ) return BadRequest ( ModelState ); // Normally this would be bus.Dispatch(...) but because of the example the command to dispatch is of type 'dynamic' which an extension method cannot handle. return Accepted ( await CommandHandlerResolverExtensions . Dispatch ( bus , commandId , CommandRequestMapping . Map ( command ), GetMetadata (), cancellationToken )); } } At this point you can focus on the domain and start reacting to the received commands .","title":"Sending Commands"},{"location":"sending-commands/#sending-commands-to-the-domain","text":"A system can receive input from various sources. Eventually all of these need to get translated into commands which are sent to the domain. The way these commands are created is up to the implementor. Commands in their turn are sent to the domain by dispatching them on a bus. In its simplest form, a command is sent over the bus using bus.Dispatch(commandId, command) towards the domain. In this example, we have an MVC controller where incoming commands are sent to as plain JSON objects for simplicity, converted into a command object and placed on the bus. public class CommandRequest { /// <summary>Type of the command.</summary> [Required] public string Type { get ; set ; } /// <summary>The raw command.</summary> [Required] public string Command { get ; set ; } } public static class CommandRequestMapping { public static dynamic Map ( CommandRequest message ) { var assembly = typeof ( DomainAssemblyMarker ). Assembly ; var type = assembly . GetType ( message . Type ); return JsonConvert . DeserializeObject ( message . Command , type ); } } public class ExampleController : ExampleRegistryController { /// <summary> /// Execute a generic command. /// </summary> /// <param name=\"bus\"></param> /// <param name=\"commandId\">Optional unique id for the request.</param> /// <param name=\"command\"></param> /// <param name=\"cancellationToken\"></param> /// <response code=\"202\">If the request is accepted.</response> /// <response code=\"400\">If the request has invalid data.</response> /// <response code=\"500\">If an internal error has occured.</response> /// <returns></returns> [HttpPost] [ProducesResponseType(typeof(void), StatusCodes.Status202Accepted)] [ProducesResponseType(typeof(BasicApiProblem), StatusCodes.Status400BadRequest)] [ProducesResponseType(typeof(BasicApiProblem), StatusCodes.Status500InternalServerError)] [SwaggerRequestExample(typeof(CommandRequest), typeof(CommandRequestExample))] [SwaggerResponseExample(StatusCodes.Status202Accepted, typeof(CommandResponseExamples), jsonConverter: typeof(StringEnumConverter))] [SwaggerResponseExample(StatusCodes.Status400BadRequest, typeof(BadRequestResponseExamples), jsonConverter: typeof(StringEnumConverter))] [SwaggerResponseExample(StatusCodes.Status500InternalServerError, typeof(InternalServerErrorResponseExamples), jsonConverter: typeof(StringEnumConverter))] public async Task < IActionResult > Post ( [FromServices] ICommandHandlerResolver bus , [FromCommandId] Guid commandId , [FromBody] CommandRequest command , CancellationToken cancellationToken = default ) { if (! ModelState . IsValid ) return BadRequest ( ModelState ); // Normally this would be bus.Dispatch(...) but because of the example the command to dispatch is of type 'dynamic' which an extension method cannot handle. return Accepted ( await CommandHandlerResolverExtensions . Dispatch ( bus , commandId , CommandRequestMapping . Map ( command ), GetMetadata (), cancellationToken )); } } At this point you can focus on the domain and start reacting to the received commands .","title":"Sending commands to the domain"},{"location":"storing-events/","text":"Storing events using SqlStreamStore \u00b6 Events are stored in Microsoft SQL Server using SqlStreamStore. Creating the database \u00b6 Create a new database in Microsoft SQL Server: IF DB_ID ( N 'your-registry' ) IS NULL EXEC ( N 'CREATE DATABASE [your-registry];' ); GO IF SERVERPROPERTY ( 'EngineEdition' ) <> 5 EXEC ( N 'ALTER DATABASE [your-registry] SET READ_COMMITTED_SNAPSHOT ON;' ); GO USE [ your - registry ] GO IF SCHEMA_ID ( N 'YourRegistry' ) IS NULL EXEC ( N 'CREATE SCHEMA [YourRegistry];' ); GO Configuring the application \u00b6 Next to the appsettings.json in YourRegistry.Api , create a new file called appsettings.your-machine.json , with your computername lower cased (e.g. appsettings.boxy.json when the computername is Boxy ). This file will contain the connection string to your newly created database: { \"ConnectionStrings\" : { \"Events\" : \"Server=.;Database=your-registry;Trusted_Connection=True;\" } } Configuring SqlStreamStore \u00b6 In src/YourRegistry.Api/Infrastructure/Startup.cs uncomment the following to allow SqlStreamStore to check and configure the database: StartupHelpers . EnsureSqlStreamStoreSchema < Startup >( streamStore , loggerFactory ); At this point when you run your Api and send the commands from previous chapter : events are saved automatically; aggregates are fetched by identifier and have their state rebuild from existing events.","title":"Storing Events"},{"location":"storing-events/#storing-events-using-sqlstreamstore","text":"Events are stored in Microsoft SQL Server using SqlStreamStore.","title":"Storing events using SqlStreamStore"},{"location":"storing-events/#creating-the-database","text":"Create a new database in Microsoft SQL Server: IF DB_ID ( N 'your-registry' ) IS NULL EXEC ( N 'CREATE DATABASE [your-registry];' ); GO IF SERVERPROPERTY ( 'EngineEdition' ) <> 5 EXEC ( N 'ALTER DATABASE [your-registry] SET READ_COMMITTED_SNAPSHOT ON;' ); GO USE [ your - registry ] GO IF SCHEMA_ID ( N 'YourRegistry' ) IS NULL EXEC ( N 'CREATE SCHEMA [YourRegistry];' ); GO","title":"Creating the database"},{"location":"storing-events/#configuring-the-application","text":"Next to the appsettings.json in YourRegistry.Api , create a new file called appsettings.your-machine.json , with your computername lower cased (e.g. appsettings.boxy.json when the computername is Boxy ). This file will contain the connection string to your newly created database: { \"ConnectionStrings\" : { \"Events\" : \"Server=.;Database=your-registry;Trusted_Connection=True;\" } }","title":"Configuring the application"},{"location":"storing-events/#configuring-sqlstreamstore","text":"In src/YourRegistry.Api/Infrastructure/Startup.cs uncomment the following to allow SqlStreamStore to check and configure the database: StartupHelpers . EnsureSqlStreamStoreSchema < Startup >( streamStore , loggerFactory ); At this point when you run your Api and send the commands from previous chapter : events are saved automatically; aggregates are fetched by identifier and have their state rebuild from existing events.","title":"Configuring SqlStreamStore"}]}