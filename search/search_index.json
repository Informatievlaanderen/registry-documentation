{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Basisregisters Vlaanderen \u00b6 License \u00b6 European Union Public Licence (EUPL) The new version 1.2 of the European Union Public Licence (EUPL) is published in the 23 EU languages in the EU Official Journal: Commission Implementing Decision (EU) 2017/863 of 18 May 2017 updating the open source software licence EUPL to further facilitate the sharing and reuse of software developed by public administrations ( OJ 19/05/2017 L128 p. 59\u201364 ).","title":"Home"},{"location":"#welcome-to-basisregisters-vlaanderen","text":"","title":"Welcome to Basisregisters Vlaanderen"},{"location":"#license","text":"European Union Public Licence (EUPL) The new version 1.2 of the European Union Public Licence (EUPL) is published in the 23 EU languages in the EU Official Journal: Commission Implementing Decision (EU) 2017/863 of 18 May 2017 updating the open source software licence EUPL to further facilitate the sharing and reuse of software developed by public administrations ( OJ 19/05/2017 L128 p. 59\u201364 ).","title":"License"},{"location":"build/","text":"Build Script \u00b6 Our build.sh script knows a few tricks. By default it runs with the Test target. The buildserver passes in BITBUCKET_BUILD_NUMBER as an integer to version the results and BUILD_DOCKER_REGISTRY to point to a Docker registry to push the resulting Docker images. NpmInstall \u00b6 Run an npm install to setup Commitizen and Semantic Release . DotNetCli \u00b6 Checks if the requested .NET Core SDK and runtime version defined in global.json are available. We are pedantic about these being the exact versions to have identical builds everywhere. Clean \u00b6 Make sure we have a clean build directory to start with. Restore \u00b6 Restore dependencies for debian.8-x64 and win10-x64 using dotnet restore and Paket. Build \u00b6 Builds the solution in Release mode with the .NET Core SDK and runtime specified in global.json It builds it platform-neutral, debian.8-x64 and win10-x64 version. Test \u00b6 Runs dotnet test against the test projects. Publish \u00b6 Runs a dotnet publish for the debian.8-x64 and win10-x64 version as a self-contained application. It does this using the Release configuration. Pack \u00b6 Packs the solution using Paket in Release mode and places the result in the dist folder. This is usually used to build documentation NuGet packages. Containerize \u00b6 Executes a docker build to package the application as a docker image. It does not use a Docker cache. The result is tagged as latest and with the current version number. DockerLogin \u00b6 Executes ci-docker-login.sh , which does an aws ecr login to login to Amazon Elastic Container Registry. This uses the local aws settings, make sure they are working! Push \u00b6 Executes docker push to push the built images to the registry.","title":"Build Script"},{"location":"build/#build-script","text":"Our build.sh script knows a few tricks. By default it runs with the Test target. The buildserver passes in BITBUCKET_BUILD_NUMBER as an integer to version the results and BUILD_DOCKER_REGISTRY to point to a Docker registry to push the resulting Docker images.","title":"Build Script"},{"location":"build/#npminstall","text":"Run an npm install to setup Commitizen and Semantic Release .","title":"NpmInstall"},{"location":"build/#dotnetcli","text":"Checks if the requested .NET Core SDK and runtime version defined in global.json are available. We are pedantic about these being the exact versions to have identical builds everywhere.","title":"DotNetCli"},{"location":"build/#clean","text":"Make sure we have a clean build directory to start with.","title":"Clean"},{"location":"build/#restore","text":"Restore dependencies for debian.8-x64 and win10-x64 using dotnet restore and Paket.","title":"Restore"},{"location":"build/#build","text":"Builds the solution in Release mode with the .NET Core SDK and runtime specified in global.json It builds it platform-neutral, debian.8-x64 and win10-x64 version.","title":"Build"},{"location":"build/#test","text":"Runs dotnet test against the test projects.","title":"Test"},{"location":"build/#publish","text":"Runs a dotnet publish for the debian.8-x64 and win10-x64 version as a self-contained application. It does this using the Release configuration.","title":"Publish"},{"location":"build/#pack","text":"Packs the solution using Paket in Release mode and places the result in the dist folder. This is usually used to build documentation NuGet packages.","title":"Pack"},{"location":"build/#containerize","text":"Executes a docker build to package the application as a docker image. It does not use a Docker cache. The result is tagged as latest and with the current version number.","title":"Containerize"},{"location":"build/#dockerlogin","text":"Executes ci-docker-login.sh , which does an aws ecr login to login to Amazon Elastic Container Registry. This uses the local aws settings, make sure they are working!","title":"DockerLogin"},{"location":"build/#push","text":"Executes docker push to push the built images to the registry.","title":"Push"},{"location":"new-registry/","text":"Starting a new registry \u00b6 To get started building a new registry, you can follow these steps: Preparing the example registry \u00b6 Downloading the example registry \u00b6 Start by downloading the example registry and extracting it in your new location. Renaming physical files to match your project \u00b6 Rename the following files to your project name: ExampleRegistry.sln ExampleRegistry.sln.DotSettings src\\ExampleRegistry src\\ExampleRegistry\\ExampleRegistry.csproj src\\ExampleRegistry\\ExampleRegistry.csproj.DotSettings src\\ExampleRegistry\\ExampleRegistryException.cs src\\ExampleRegistry.Api src\\ExampleRegistry.Api\\ExampleRegistry.Api.csproj src\\ExampleRegistry.Api\\ExampleRegistry.Api.csproj.DotSettings src\\ExampleRegistry.Infrastructure src\\ExampleRegistry.Infrastructure\\ExampleRegistry.Infrastructure.csproj test\\ExampleRegistry.Tests test\\ExampleRegistry.Tests\\ExampleRegistry.Tests.csproj test\\ExampleRegistry.Tests\\ExampleRegistryTest.cs docs\\ExampleRegistry.Structurizr docs\\ExampleRegistry.Structurizr\\ExampleRegistry.Structurizr.csproj Renaming code to match your project \u00b6 Do a case sensitive search in all files for the following and replace it, respecting the casing: Project Details \u00b6 ExampleRegistry to your project name. example-registry to your project name. exampleregistry to your project name. exampleRegistry to your project name. Example Registry to your project name. Example Api to your project name + Api . Write a short summary of the business goal of this registry. to clarify what your project is about. Organisation Details \u00b6 informatievlaanderen to your organisation GitHub name. agentschap Informatie Vlaanderen to your organisation name. Basisregisters Vlaanderen to your organisation name. Informatie Vlaanderen to your organisation name. Vlaamse overheid to your organisation name. informatie.vlaanderen@vlaanderen.be to your organisation contact email address. https://vlaanderen.be/informatie-vlaanderen to your organisation website address. \"Havenlaan 88\" to your organisation street. \"1000\" to your organisation postal code. \"Brussel\" to your organisation city. Generate unique assembly Guids \u00b6 Search for [assembly: Guid in every AssemblyInfo.cs and generate a new guid for each. Enabling HTTPS with a certificate \u00b6 In src\\ExampleRegistry.Api\\Infrastructure\\Program.cs there is a DevelopmentCertificate property used to configure the SSL certificate. If you wish to use example.pfx , which is a self-signed certificate for localhost , use the password example-registry! Building for the first time \u00b6 Run build.sh Pack to verify everything is correct. This will also pull down all required packages to later open the solution properly with Visual Studio. Running the registry using Visual Studio \u00b6 To try out the registry for the first time, open up YourRegistry.sln in Visual Studio. Set YourRegistry.Api as a startup project and select YourRegistry.Api as Debug Emulator instead of IIS Express . Start the registry and browse to localhost:1090 , you should see the API documentation. Browsing to localhost:1090/v1/example/SOMEKEY should return SOMEKEY . At this point you have a working development environment to build upon.","title":"New Registry"},{"location":"new-registry/#starting-a-new-registry","text":"To get started building a new registry, you can follow these steps:","title":"Starting a new registry"},{"location":"new-registry/#preparing-the-example-registry","text":"","title":"Preparing the example registry"},{"location":"new-registry/#downloading-the-example-registry","text":"Start by downloading the example registry and extracting it in your new location.","title":"Downloading the example registry"},{"location":"new-registry/#renaming-physical-files-to-match-your-project","text":"Rename the following files to your project name: ExampleRegistry.sln ExampleRegistry.sln.DotSettings src\\ExampleRegistry src\\ExampleRegistry\\ExampleRegistry.csproj src\\ExampleRegistry\\ExampleRegistry.csproj.DotSettings src\\ExampleRegistry\\ExampleRegistryException.cs src\\ExampleRegistry.Api src\\ExampleRegistry.Api\\ExampleRegistry.Api.csproj src\\ExampleRegistry.Api\\ExampleRegistry.Api.csproj.DotSettings src\\ExampleRegistry.Infrastructure src\\ExampleRegistry.Infrastructure\\ExampleRegistry.Infrastructure.csproj test\\ExampleRegistry.Tests test\\ExampleRegistry.Tests\\ExampleRegistry.Tests.csproj test\\ExampleRegistry.Tests\\ExampleRegistryTest.cs docs\\ExampleRegistry.Structurizr docs\\ExampleRegistry.Structurizr\\ExampleRegistry.Structurizr.csproj","title":"Renaming physical files to match your project"},{"location":"new-registry/#renaming-code-to-match-your-project","text":"Do a case sensitive search in all files for the following and replace it, respecting the casing:","title":"Renaming code to match your project"},{"location":"new-registry/#project-details","text":"ExampleRegistry to your project name. example-registry to your project name. exampleregistry to your project name. exampleRegistry to your project name. Example Registry to your project name. Example Api to your project name + Api . Write a short summary of the business goal of this registry. to clarify what your project is about.","title":"Project Details"},{"location":"new-registry/#organisation-details","text":"informatievlaanderen to your organisation GitHub name. agentschap Informatie Vlaanderen to your organisation name. Basisregisters Vlaanderen to your organisation name. Informatie Vlaanderen to your organisation name. Vlaamse overheid to your organisation name. informatie.vlaanderen@vlaanderen.be to your organisation contact email address. https://vlaanderen.be/informatie-vlaanderen to your organisation website address. \"Havenlaan 88\" to your organisation street. \"1000\" to your organisation postal code. \"Brussel\" to your organisation city.","title":"Organisation Details"},{"location":"new-registry/#generate-unique-assembly-guids","text":"Search for [assembly: Guid in every AssemblyInfo.cs and generate a new guid for each.","title":"Generate unique assembly Guids"},{"location":"new-registry/#enabling-https-with-a-certificate","text":"In src\\ExampleRegistry.Api\\Infrastructure\\Program.cs there is a DevelopmentCertificate property used to configure the SSL certificate. If you wish to use example.pfx , which is a self-signed certificate for localhost , use the password example-registry!","title":"Enabling HTTPS with a certificate"},{"location":"new-registry/#building-for-the-first-time","text":"Run build.sh Pack to verify everything is correct. This will also pull down all required packages to later open the solution properly with Visual Studio.","title":"Building for the first time"},{"location":"new-registry/#running-the-registry-using-visual-studio","text":"To try out the registry for the first time, open up YourRegistry.sln in Visual Studio. Set YourRegistry.Api as a startup project and select YourRegistry.Api as Debug Emulator instead of IIS Express . Start the registry and browse to localhost:1090 , you should see the API documentation. Browsing to localhost:1090/v1/example/SOMEKEY should return SOMEKEY . At this point you have a working development environment to build upon.","title":"Running the registry using Visual Studio"},{"location":"reacting-to-commands/","text":"Reacting to commands \u00b6 The main input of a system is commands, which are handled by command handlers. We support two different type of command handlers, regular ones and event sourced handlers. Regular Command Handlers \u00b6 A regular command handler is simply a class which is subscribed to commands and does not need anything from the event sourcing infrastructure. This means it is not possible to easily fetch aggregates nor store events to the event store. Registering \u00b6 To register this type of command handler, use the following syntax in the CommandHandlerModules registration: // Syntax for commandhandlers which do not use SqlStreamStore to store events containerBuilder . RegisterType < SimpleExampleCommandHandlerModule >() . Named < CommandHandlerModule >( typeof ( SimpleExampleCommandHandlerModule ). FullName ) . As < CommandHandlerModule >(); Implementation \u00b6 A handler can then simple register commands with the For syntax and receive the message : public sealed class SimpleExampleCommandHandlerModule : CommandHandlerModule { public SimpleExampleCommandHandlerModule () { For < DoSimpleExample >() . Handle ( message => { Console . WriteLine ( $ \"A simple example arrived, saying {message.Command.Name.Name} in {message.Command.Name.Language}!\" ); }); } } Event Sourced Command Handlers \u00b6 Event sourced command handlers are able to easily get aggregates by id from a repository, create new aggregates as well as transparently store created events using SqlStreamStore. Registering \u00b6 To register this type of command handler, use the following syntax in the CommandHandlerModules registration: // Syntax for EventSourcing with SqlStreamStore containerBuilder . RegisterSqlStreamStoreCommandHandler < ExampleCommandHandlerModule >( c => handler => new ExampleCommandHandlerModule ( c . Resolve < Func < IExamples >>(), handler )); Implementation \u00b6 A handler also uses For to register for commands but it uses a finalHandler to enable auto-saving of events. For example, this handler looks up an aggregate based on an identifier and if it does not exist, creates the aggregate and adds it to the repository: public sealed class ExampleCommandHandlerModule : CommandHandlerModule { public ExampleCommandHandlerModule ( Func < IExamples > getExamples , ReturnHandler < CommandMessage > finalHandler = null ) : base ( finalHandler ) { For < DoExample >() . Handle ( async ( message , ct ) => { var examples = getExamples (); var exampleId = message . Command . ExampleId ; var possibleExample = await examples . GetOptionalAsync ( exampleId , ct ); if (! possibleExample . HasValue ) { possibleExample = new Optional < Example >( Example . Register ( exampleId )); examples . Add ( exampleId , possibleExample . Value ); } var example = possibleExample . Value ; example . DoExample ( message . Command . Name ); }); } } The above code calls DoExample on an aggregate which generates events and are saved automatically when the command is handled. The aggregate looks as follows: public partial class Example : AggregateRootEntity { public static readonly Func < Example > Factory = () => new Example (); public static Example Register ( ExampleId id ) { var example = Factory (); example . ApplyChange ( new ExampleWasBorn ( id )); return example ; } public void DoExample ( ExampleName name ) { ApplyChange ( new ExampleHappened ( _exampleId , name )); } }","title":"Receiving Commands"},{"location":"reacting-to-commands/#reacting-to-commands","text":"The main input of a system is commands, which are handled by command handlers. We support two different type of command handlers, regular ones and event sourced handlers.","title":"Reacting to commands"},{"location":"reacting-to-commands/#regular-command-handlers","text":"A regular command handler is simply a class which is subscribed to commands and does not need anything from the event sourcing infrastructure. This means it is not possible to easily fetch aggregates nor store events to the event store.","title":"Regular Command Handlers"},{"location":"reacting-to-commands/#registering","text":"To register this type of command handler, use the following syntax in the CommandHandlerModules registration: // Syntax for commandhandlers which do not use SqlStreamStore to store events containerBuilder . RegisterType < SimpleExampleCommandHandlerModule >() . Named < CommandHandlerModule >( typeof ( SimpleExampleCommandHandlerModule ). FullName ) . As < CommandHandlerModule >();","title":"Registering"},{"location":"reacting-to-commands/#implementation","text":"A handler can then simple register commands with the For syntax and receive the message : public sealed class SimpleExampleCommandHandlerModule : CommandHandlerModule { public SimpleExampleCommandHandlerModule () { For < DoSimpleExample >() . Handle ( message => { Console . WriteLine ( $ \"A simple example arrived, saying {message.Command.Name.Name} in {message.Command.Name.Language}!\" ); }); } }","title":"Implementation"},{"location":"reacting-to-commands/#event-sourced-command-handlers","text":"Event sourced command handlers are able to easily get aggregates by id from a repository, create new aggregates as well as transparently store created events using SqlStreamStore.","title":"Event Sourced Command Handlers"},{"location":"reacting-to-commands/#registering_1","text":"To register this type of command handler, use the following syntax in the CommandHandlerModules registration: // Syntax for EventSourcing with SqlStreamStore containerBuilder . RegisterSqlStreamStoreCommandHandler < ExampleCommandHandlerModule >( c => handler => new ExampleCommandHandlerModule ( c . Resolve < Func < IExamples >>(), handler ));","title":"Registering"},{"location":"reacting-to-commands/#implementation_1","text":"A handler also uses For to register for commands but it uses a finalHandler to enable auto-saving of events. For example, this handler looks up an aggregate based on an identifier and if it does not exist, creates the aggregate and adds it to the repository: public sealed class ExampleCommandHandlerModule : CommandHandlerModule { public ExampleCommandHandlerModule ( Func < IExamples > getExamples , ReturnHandler < CommandMessage > finalHandler = null ) : base ( finalHandler ) { For < DoExample >() . Handle ( async ( message , ct ) => { var examples = getExamples (); var exampleId = message . Command . ExampleId ; var possibleExample = await examples . GetOptionalAsync ( exampleId , ct ); if (! possibleExample . HasValue ) { possibleExample = new Optional < Example >( Example . Register ( exampleId )); examples . Add ( exampleId , possibleExample . Value ); } var example = possibleExample . Value ; example . DoExample ( message . Command . Name ); }); } } The above code calls DoExample on an aggregate which generates events and are saved automatically when the command is handled. The aggregate looks as follows: public partial class Example : AggregateRootEntity { public static readonly Func < Example > Factory = () => new Example (); public static Example Register ( ExampleId id ) { var example = Factory (); example . ApplyChange ( new ExampleWasBorn ( id )); return example ; } public void DoExample ( ExampleName name ) { ApplyChange ( new ExampleHappened ( _exampleId , name )); } }","title":"Implementation"}]}